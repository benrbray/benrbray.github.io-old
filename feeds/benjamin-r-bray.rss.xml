<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Benjamin R. Bray - Benjamin R. Bray</title><link>https://benrbray.com/</link><description></description><lastBuildDate>Wed, 16 Sep 2020 00:00:00 -0400</lastBuildDate><item><title>Noteworthy</title><link>https://benrbray.com/posts/2020/noteworthy</link><description>&lt;p&gt;An open-source Markdown editor with bidirectional links and excellent math support!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Wed, 16 Sep 2020 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2020-09-16:/posts/2020/noteworthy</guid><category>note-taking</category><category>math</category></item><item><title>ProseMirror Math</title><link>https://benrbray.com/posts/2020/prosemirror-math</link><description>&lt;p&gt;Schema and plugins for math editing using ProseMirror!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Sun, 14 Jun 2020 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2020-06-14:/posts/2020/prosemirror-math</guid><category>math</category><category>text-editor</category></item><item><title>Backbite Algorithm for Sampling Hamiltonian Paths</title><link>https://benrbray.com/posts/2020/backbite-algorithm-for-sampling-hamiltonian-paths</link><description>&lt;p&gt;A Hamiltonian graph may have more than one Hamiltonian path.  Suppose we have a graph &lt;span class="math"&gt;\(G=(V,E)\)&lt;/span&gt; that we &lt;b&gt;know&lt;/b&gt; is Hamiltonian, perhaps because we already have a Hamiltonian path &lt;span class="math"&gt;\(p\)&lt;/span&gt;.  Is it possible to sample a random Hamiltonian path uniformly at random from &lt;span class="math"&gt;\(G\)&lt;/span&gt;?&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Mon, 23 Mar 2020 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2020-03-23:/posts/2020/backbite-algorithm-for-sampling-hamiltonian-paths</guid><category>algorithms</category><category>graph-theory</category></item><item><title>About This Website</title><link>https://benrbray.com/posts/2020/about-this-website</link><description>&lt;p&gt;Things I learned while making this website.  Web standards change quickly!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Fri, 20 Mar 2020 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2020-03-20:/posts/2020/about-this-website</guid><category>web-dev</category></item><item><title>Real-time Game Physics</title><link>https://benrbray.com/posts/2020/real-time-game-physics</link><description>&lt;p&gt;Real-time Game Physics&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Fri, 20 Mar 2020 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2020-03-20:/posts/2020/real-time-game-physics</guid><category>geometry</category><category>game-dev</category><category>linear-algebra</category></item><item><title>Collision Detection: Convex Geometry</title><link>https://benrbray.com/posts/2020/collision-detection-convex-geometry</link><description>Working with convex polygons.</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Wed, 18 Mar 2020 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2020-03-18:/posts/2020/collision-detection-convex-geometry</guid><category>geometry</category><category>linear-algebra</category><category>game-dev</category><category>graphics</category></item><item><title>Collision Detection: GJK &amp; EPA</title><link>https://benrbray.com/posts/2020/collision-detection-gjk-epa</link><description>&lt;p&gt;The Gilbert–Johnson–Keerthi distance algorithm is a method of determining the minimum distance between two convex sets. Unlike many other distance algorithms, it does not require that the geometry data be stored in any specific format, but instead relies solely on a support function to iteratively generate closer simplices to the correct answer using the configuration space obstacle (CSO) of two convex shapes, more commonly known as the Minkowski difference.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Wed, 18 Mar 2020 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2020-03-18:/posts/2020/collision-detection-gjk-epa</guid><category>geometry</category><category>linear-algebra</category><category>game-dev</category><category>graphics</category></item><item><title>SVG</title><link>https://benrbray.com/posts/2020/svg</link><description>&lt;p&gt;What I've learned about the Scalable Vector Graphics (SVG) format.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Tue, 03 Mar 2020 00:00:00 -0500</pubDate><guid isPermaLink="false">tag:benrbray.com,2020-03-03:/posts/2020/svg</guid><category>svg</category><category>drawing</category></item><item><title>Boggle / Unboggle</title><link>https://benrbray.com/posts/2020/boggle-unboggle</link><description>Finds all words in a boggle board using the trie data structure.</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Mon, 02 Mar 2020 00:00:00 -0500</pubDate><guid isPermaLink="false">tag:benrbray.com,2020-03-02:/posts/2020/boggle-unboggle</guid><category>algorithms</category><category>satisfiability</category></item><item><title>Hough Transform</title><link>https://benrbray.com/posts/2020/hough-transform</link><description>&lt;p&gt;Detect lines in an image with the Hough transform.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Fri, 10 Jan 2020 00:00:00 -0500</pubDate><guid isPermaLink="false">tag:benrbray.com,2020-01-10:/posts/2020/hough-transform</guid><category>image-processing</category></item><item><title>東京の散歩</title><link>https://benrbray.com/posts/2019/dong-jing-nosan-bu</link><description>&lt;p&gt;I made a map of everywhere I walked and biked in Tokyo during Summer 2019!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Sat, 14 Sep 2019 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2019-09-14:/posts/2019/dong-jing-nosan-bu</guid><category>tokyo</category><category>japan</category><category>travel</category></item><item><title>Newton's Method, Optimization, and Root-finding</title><link>https://benrbray.com/posts/2019/newtons-method-optimization-and-root-finding</link><description>&lt;p&gt;There are two versions of Newton's method, one for root-finding, &lt;span class="math"&gt;\(f(x) = 0\)&lt;/span&gt;, and one for optimization, &lt;span class="math"&gt;\(min_{x \in \R^n} f(x)\)&lt;/span&gt;.  In this post, I show explicitly that Newton's method for optimization is simply Newton's method applied to finding fixed points of the gradient map &lt;span class="math"&gt;\(x \mapsto \nabla x f\)&lt;/span&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Wed, 21 Aug 2019 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2019-08-21:/posts/2019/newtons-method-optimization-and-root-finding</guid></item><item><title>Gradients are Row Vectors (and you can too!)</title><link>https://benrbray.com/posts/2019/gradients-are-row-vectors-and-you-can-too</link><description>&lt;p&gt;Mathematicians tend to agree that gradients are row vectors, but for some reason computer scientists can't get on borad with the idea.  The goal of this post is to explain why gradients are most naturally expressed as row vectors, and to demonstrate the advantages of this perspective.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Tue, 20 Aug 2019 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2019-08-20:/posts/2019/gradients-are-row-vectors-and-you-can-too</guid></item><item><title>Path-Sensitive Data-Flow Analysis with LLVM</title><link>https://benrbray.com/posts/2019/path-sensitive-data-flow-analysis-with-llvm</link><description>&lt;p&gt;Implementation of Thakur &amp;amp; Govindarajan 2008, "Comprehensive Path-Sensitive Data-Flow Analysis" as an LLVM transformation pass.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Mon, 15 Apr 2019 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2019-04-15:/posts/2019/path-sensitive-data-flow-analysis-with-llvm</guid><category>compilers</category><category>programming-languages</category><category>llvm</category></item><item><title>Superscalar Processor</title><link>https://benrbray.com/posts/2019/superscalar-processor</link><description>&lt;p&gt;Toy implementation of a superscalar processor.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Fri, 08 Mar 2019 00:00:00 -0500</pubDate><guid isPermaLink="false">tag:benrbray.com,2019-03-08:/posts/2019/superscalar-processor</guid><category>compilers</category><category>programming-languages</category><category>llvm</category></item><item><title>Algorithms for Random Discrete Structures</title><link>https://benrbray.com/posts/2018/algorithms-for-random-discrete-structures</link><description>&lt;p&gt;Many applications require the random sampling of matrices with prescribed structure for modeling, statistical, or aesthetic purposes.  What does it mean for a random variable to be matrix-valued?  What can we say about the eigenvalues of a random matrix?  How can we design algorithms to sample from a target distribution on a group or manifold?  More generally, what can we say deterministic algorithms with random inputs?  Our study of random matrices will lead us to the &lt;em&gt;subgroup algorithm&lt;/em&gt; (Diaconis 1987), which subsumes many familiar random sampling procedures.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Wed, 02 May 2018 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2018-05-02:/posts/2018/algorithms-for-random-discrete-structures</guid></item><item><title>Collision Detection: Minkowski Sum</title><link>https://benrbray.com/posts/2018/collision-detection-minkowski-sum</link><description>&lt;p&gt;Introduces the Minkowski sum and its applications to game physics.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Fri, 27 Apr 2018 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2018-04-27:/posts/2018/collision-detection-minkowski-sum</guid><category>geometry</category><category>linear-algebra</category><category>game-dev</category><category>graphics</category></item><item><title>Molecules</title><link>https://benrbray.com/posts/2018/molecules</link><description>&lt;p&gt;Simulation of molecules with hydrodynamic interactions.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Thu, 01 Mar 2018 00:00:00 -0500</pubDate><guid isPermaLink="false">tag:benrbray.com,2018-03-01:/posts/2018/molecules</guid><category>algorithms</category><category>simulation</category></item><item><title>Collision Detection: Separating Axis Theorem</title><link>https://benrbray.com/posts/2017/collision-detection-separating-axis-theorem</link><description>&lt;p&gt;In geometry, the hyperplane separation theorem is a theorem about disjoint convex sets in n-dimensional Euclidean space. There are several rather similar versions. In one version of the theorem, if both these sets are closed and at least one of them is compact, then there is a hyperplane in between them and even two parallel hyperplanes in between them separated by a gap. In another version, if both disjoint convex sets are open, then there is a hyperplane in between them, but not necessarily any gap. An axis which is orthogonal to a separating hyperplane is a separating axis, because the orthogonal projections of the convex bodies onto the axis are disjoint.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Sat, 17 Jun 2017 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2017-06-17:/posts/2017/collision-detection-separating-axis-theorem</guid><category>geometry</category><category>linear-algebra</category><category>game-dev</category><category>graphics</category></item><item><title>Generating Random Samples</title><link>https://benrbray.com/posts/2017/generating-random-samples</link><description>&lt;p&gt;What is the most effective way to generate random samples, assuming we have access to a pseudorandom number generator?  In this post, we'll explore several common algorithms.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Sat, 17 Jun 2017 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2017-06-17:/posts/2017/generating-random-samples</guid></item><item><title>Digital Humanities &amp; German Periodicals</title><link>https://benrbray.com/posts/2016/digital-humanities-german-periodicals</link><description>&lt;p&gt;As an undergraduate research assistant, I spent three years as the primary developer for an NLP-driven web application built to assist a humanities professor with his research on 19th-century German literature.  The application allowed him to run statistical topic models (LDA, HDP, dynamic topic models, etc.) on a large corpus of text, and displayed helpful visualizations of the results.  The application was built using Python / Flask / Bootstrap and also supported toponym detection and full-text search.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Thu, 01 Dec 2016 00:00:00 -0500</pubDate><guid isPermaLink="false">tag:benrbray.com,2016-12-01:/posts/2016/digital-humanities-german-periodicals</guid><category>nlp</category><category>topic-models</category><category>machine-learning</category><category>web-dev</category></item><item><title>Rigid Body Dynamics</title><link>https://benrbray.com/posts/2016/rigid-body-dynamics</link><description>&lt;p&gt;Fast and accurate rigid body dynamics for games!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Thu, 01 Dec 2016 00:00:00 -0500</pubDate><guid isPermaLink="false">tag:benrbray.com,2016-12-01:/posts/2016/rigid-body-dynamics</guid><category>linear-algebra</category><category>game-dev</category></item><item><title>Expectation Maximization</title><link>https://benrbray.com/posts/2015/expectation-maximization</link><description>&lt;p&gt;These notes provide a theoretical treatment of &lt;strong&gt;Expectation-Maximization&lt;/strong&gt;, an iterative parameter estimation algorithm used to find local maxima of the likelihood function in the presence of hidden variables.  Introductory textbooks (MLAPP, PRML) typically state the algorithm without explanation and expect students to work blindly through derivations.  We find this approach to be unsatisfying, and instead choose to tackle the theory head-on, followed by plenty of examples.  Following (Neal &amp;amp; Hinton 1998), we view expectation-maximization as coordinate ascent on the &lt;strong&gt;Evidence Lower Bound&lt;/strong&gt;.  This perspective takes much of the mystery out of the algorithm and allows us to easily derive variants like &lt;strong&gt;Hard EM&lt;/strong&gt; and &lt;strong&gt;Variational Inference&lt;/strong&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Thu, 26 Nov 2015 00:00:00 -0500</pubDate><guid isPermaLink="false">tag:benrbray.com,2015-11-26:/posts/2015/expectation-maximization</guid></item><item><title>Incompressible Fluid Simulation</title><link>https://benrbray.com/posts/2015/incompressible-fluid-simulation</link><description>&lt;p&gt;Simulation of two-dimensional incompressible flow with periodic boundary conditions, achieved by solving the Euler Equations in the frequency domain via the Fast Fourier Transform (FFT).  Written in Java.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Fri, 21 Aug 2015 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2015-08-21:/posts/2015/incompressible-fluid-simulation</guid><category>fluid-simulation</category><category>graphics</category><category>gpu</category><category>numerical-methods</category></item><item><title>Maze Generation</title><link>https://benrbray.com/posts/2015/maze-generation</link><description>&lt;p&gt;Comparison of maze generation algorithms.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Fri, 20 Mar 2015 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2015-03-20:/posts/2015/maze-generation</guid><category>algorithms</category></item><item><title>Seam Carving</title><link>https://benrbray.com/posts/2014/seam-carving</link><description>&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Seam_carving"&gt;Seam Carving&lt;/a&gt; is a classic dynamic programming algorithm for content-aware image resizing.  Rather than scaling or cropping, the seam carving algorithm resizes images by removing (or copying) horizontal and vertical slices of the image.  These slices, called &lt;em&gt;seams&lt;/em&gt;, must cross the entire image, but are allowed to zig and zag around salient regions in order to avoid too much deformation.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Sun, 28 Dec 2014 00:00:00 -0500</pubDate><guid isPermaLink="false">tag:benrbray.com,2014-12-28:/posts/2014/seam-carving</guid><category>image-processing</category><category>algorithms</category></item><item><title>Code Diff</title><link>https://benrbray.com/posts/2014/code-diff</link><description>&lt;p&gt;Git-style code diff with the Longest Common Subsequence algorithm.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Sat, 13 Dec 2014 00:00:00 -0500</pubDate><guid isPermaLink="false">tag:benrbray.com,2014-12-13:/posts/2014/code-diff</guid><category>algorithms</category></item><item><title>AdamBots Automated Scouting Kit</title><link>https://benrbray.com/posts/2014/adambots-automated-scouting-kit</link><description>&lt;p&gt;Match prediction and analysis for FIRST FRC competitions.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Sun, 01 Jun 2014 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:benrbray.com,2014-06-01:/posts/2014/adambots-automated-scouting-kit</guid><category>linear-algebra</category><category>robotics</category></item><item><title>Complex Domain Coloring</title><link>https://benrbray.com/posts/2014/complex-domain-coloring</link><description>&lt;p&gt;Complex domain coloring implemented with JavaScript / Canvas.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Benjamin R. Bray</dc:creator><pubDate>Sat, 15 Feb 2014 00:00:00 -0500</pubDate><guid isPermaLink="false">tag:benrbray.com,2014-02-15:/posts/2014/complex-domain-coloring</guid><category>math</category><category>complex-analysis</category><category>image-processing</category></item></channel></rss>